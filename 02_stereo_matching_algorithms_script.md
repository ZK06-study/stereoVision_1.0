# 🔍 스테레오 매칭 알고리즘 심화 실습 - 과외 수업 스크립트

## 📋 수업 개요
- **수업 시간**: 100분 (휴식 10분 포함)
- **난이도**: 중급 ~ 고급
- **학습 목표**: 스테레오 매칭 알고리즘 직접 구현 및 비교 분석
- **선수 지식**: 기본 스테레오비전 개념, Python/NumPy 기초

---

## 🎯 수업 진행 시나리오 (100분)

### **도입부 및 복습 (10분) - 0:00~0:10**

**선생님:** "지난 시간에 OpenCV의 StereoBM을 사용해봤죠? 오늘은 그 알고리즘이 실제로 어떻게 작동하는지 직접 구현해볼 거예요!"

#### 🔄 지난 시간 복습
- 시차(disparity)의 개념
- 블록 매칭의 기본 아이디어
- OpenCV StereoBM 사용법

**예상 질문 대응:**
- **Q:** "왜 직접 구현하나요? OpenCV 쓰면 되잖아요?"
- **A:** "알고리즘의 원리를 이해해야 매개변수 조정, 문제 해결, 성능 최적화가 가능해집니다!"

### **환경 설정 및 향상된 테스트 이미지 생성 (15분) - 0:10~0:25**

**첫 번째 셀 실행 - 라이브러리 import**
**두 번째 셀 실행 - create_enhanced_test_images()**

#### 📈 향상된 테스트 이미지의 특징
1. **다양한 시차 객체들**
   - NEAR: 20픽셀 시차 (가까운 물체)
   - 중간 원: 12픽셀 시차 (중간 거리)
   - FAR: 6픽셀 시차 (먼 물체)

2. **현실적인 요소들**
   - 텍스처 패턴 (선형 패턴)
   - 체스보드 패턴
   - 가우시안 노이즈

**선생님:** "실제 환경에서는 이런 다양한 패턴과 노이즈가 있어요. 우리 알고리즘이 이를 얼마나 잘 처리하는지 확인해봅시다!"

#### 👁️ 시각적 분석 가이드
- 좌우 이미지를 번갈아 보며 시차 확인
- 각 객체별 이동 거리 측정
- 텍스처가 매칭에 미치는 영향 토론

### **StereoMatcher 기본 클래스 구현 (20분) - 0:25~0:45**

**세 번째 셀 실행 - StereoMatcher 클래스**

#### 🏗️ 클래스 설계 철학 설명
```python
class StereoMatcher:
    def __init__(self, max_disparity=32, window_size=5):
        # 매개변수 검증
        if window_size % 2 == 0:
            raise ValueError("윈도우 크기는 홀수여야 합니다.")
```

#### 🔧 핵심 개념 설명
1. **윈도우 크기가 홀수인 이유**
   - 중심 픽셀 기준으로 대칭 필요
   - 5x5 → 중심 ±2픽셀씩

2. **유효 영역 계산**
   ```python
   start_x = self.half_window + self.max_disparity
   ```
   - 왜 max_disparity만큼 추가로 빼야 하는가?
   - 경계 조건의 중요성

#### 💡 학생 이해도 체크
**실습:** 다른 윈도우 크기로 객체 생성해보기
- window_size=3, 7, 9로 실험
- 각각의 계산량과 정확도 트레이드오프 논의

### **SAD 알고리즘 구현 (25분) - 0:45~1:10**

**네 번째 셀 실행 - compute_sad_disparity() 함수**

#### 📊 SAD (Sum of Absolute Differences) 상세 설명

1. **수학적 공식**
   ```
   SAD(x,y,d) = Σ Σ |I_left(x+i, y+j) - I_right(x+i-d, y+j)|
                i  j
   ```

2. **단계별 구현 과정**
   ```python
   # 1단계: 비교할 윈도우 추출
   left_window = left_img[y:y+ws, x:x+ws]
   right_window = right_img[y:y+ws, x-d:x-d+ws]
   
   # 2단계: 절댓값 차이 계산
   diff = np.abs(left_window.astype(np.float32) - 
                 right_window.astype(np.float32))
   
   # 3단계: 합계 계산
   sad_value = np.sum(diff)
   ```

#### 🎯 구현 시 주의사항
- **데이터 타입**: uint8 → float32 변환 필요성
- **오버플로우 방지**: 음수 결과 가능성
- **경계 처리**: 윈도우가 영상 밖으로 나가는 경우

**선생님:** "왜 절댓값을 사용할까요? 양수와 음수 차이가 상쇄되는 것을 방지하기 위해서입니다!"

#### 📈 진행률 표시의 중요성
```python
if show_progress and y % progress_step == 0:
    print(f"진행률: {y/valid_height*100:.1f}%")
```
- 학생의 불안감 해소
- 알고리즘 복잡도 체감

### **휴식 시간 (10분) - 1:10~1:20**

---

### **SSD 알고리즘 구현 (15분) - 1:20~1:35**

**다섯 번째 셀 실행 - compute_ssd_disparity() 함수**

#### 📈 SSD (Sum of Squared Differences) 특징

1. **SAD와의 차이점**
   ```python
   # SAD
   diff = np.abs(left_window - right_window)
   
   # SSD  
   diff = (left_window - right_window) ** 2
   ```

2. **제곱의 효과**
   - 큰 차이에 더 큰 가중치
   - 이상값(outlier)에 더 민감
   - 노이즈에 취약할 수 있음

#### 🔍 비교 실습
- 같은 이미지에 대해 SAD와 SSD 결과 비교
- 노이즈가 많은 영역에서의 차이점 관찰

**선생님:** "어떤 상황에서 SSD가 더 좋을까요? 텍스처가 명확하고 노이즈가 적은 환경에서입니다!"

### **Census Transform 구현 (20분) - 1:35~1:55**

**여섯 번째 셀 실행 - Census Transform 알고리즘**

#### 🎭 Census Transform의 혁신성

1. **기본 아이디어**
   - 절댓값 대신 상대적 밝기 관계 사용
   - 조명 변화에 강인함
   - 이진 패턴으로 변환

2. **구현 과정**
   ```python
   # 중심 픽셀 대비 주변 픽셀들의 밝기 비교
   center = window[center_y, center_x]
   census = 0
   for dy in range(-half_window, half_window+1):
       for dx in range(-half_window, half_window+1):
           if window[center_y+dy, center_x+dx] > center:
               census |= (1 << bit_index)
   ```

3. **해밍 거리 계산**
   ```python
   # XOR 연산으로 다른 비트 개수 계산
   hamming = bin(census1 ^ census2).count('1')
   ```

#### 🔬 Census Transform의 장점
- **조명 불변성**: 균일한 조명 변화에 강함
- **콘트라스트 불변성**: 전체적인 밝기 변화에 강함
- **계산 효율성**: 비트 연산으로 빠른 계산

**실습:** 조명이 다른 이미지로 테스트해보기

### **Winner-Takes-All 구현 및 성능 비교 (15분) - 1:55~2:10**

**일곱 번째 셀 실행 - 성능 비교**

#### 🏆 Winner-Takes-All 방법
```python
# 각 시차별 비용 중 최소값 선택
best_disparity = np.argmin(cost_volume, axis=2)
```

#### 📊 성능 지표 분석
1. **처리 시간 비교**
   - SAD: 가장 빠름
   - SSD: SAD와 비슷
   - Census: 상대적으로 느림 (비트 연산 때문)

2. **품질 평가**
   - 시각적 비교
   - 노이즈 정도
   - 경계 선명도

#### 🔍 결과 해석 가이드
**선생님:** "각 알고리즘의 특성을 보세요!"
- **SAD**: 빠르지만 노이즈 많음
- **SSD**: 대비가 명확한 영역에서 좋음  
- **Census**: 조명 변화에 강하지만 느림

### **마무리 및 실제 응용 논의 (10분) - 2:10~2:20**

#### 📝 오늘 배운 내용 정리
1. **세 가지 매칭 알고리즘의 원리와 구현**
2. **각 알고리즘의 장단점과 적용 상황**
3. **Winner-Takes-All 방법**

#### 🚀 실제 산업 응용 사례
- **자동차**: Tesla Autopilot에서 Census Transform 활용
- **로봇공학**: 실시간성이 중요한 곳에서 SAD 사용
- **의료영상**: 정확도가 중요한 곳에서 SSD 또는 고급 알고리즘

#### 🤚 질의응답 시간
**예상 질문들:**

**Q:** "실제로는 어떤 알고리즘을 쓰나요?"
**A:** "상황에 따라 다릅니다. 실시간이 중요하면 SAD, 정확도가 중요하면 SGBM 등 고급 알고리즘을 사용해요."

**Q:** "OpenCV 말고 다른 라이브러리는?"
**A:** "PCL(Point Cloud Library), Open3D 등이 있고, GPU 가속을 위해 CUDA도 사용합니다."

---

## 🎯 수업 운영 팁

### **코딩 실습 지도법**
1. **단계별 진행**: 한 번에 모든 코드 보여주지 말고 단계별로
2. **에러 유도**: 의도적으로 버그 만들어 디버깅 연습
3. **매개변수 실험**: 다양한 값으로 실험하며 직관 기르기

### **이론과 실습의 균형**
- **수학 공식**: 너무 깊게 들어가지 말고 직관적 설명
- **코드 이해**: 핵심 로직 위주로 설명
- **결과 분석**: 시각적 비교를 통한 이해

### **학생 참여 극대화**
1. **예측 게임**: "이 매개변수를 바꾸면 어떻게 될까요?"
2. **문제 해결**: "노이즈가 너무 많네요. 어떻게 개선할까요?"
3. **창의적 실험**: "다른 패턴으로도 테스트해볼까요?"

### **시간 관리 전략**
- **코드 실행 시간**: Census Transform은 시간이 오래 걸림
- **설명 깊이 조절**: 학생 수준에 맞춰 조정
- **실습 시간 확보**: 이론 50%, 실습 50%

---

## 📚 추가 학습 자료

### **심화 실습 과제**
1. **다른 비용 함수 구현**: NCC(Normalized Cross Correlation)
2. **후처리 기법**: 메디안 필터, 좌우 일관성 체크
3. **성능 최적화**: 룩업 테이블, 병렬처리

### **추천 논문**
- "A Taxonomy and Evaluation of Dense Two-Frame Stereo Correspondence Algorithms" (Scharstein & Szeliski)
- "Accurate, Dense, and Robust Multiview Stereopsis" (Furukawa & Ponce)

### **다음 수업 예고**
- **깊이 계산**: 시차를 실제 거리로 변환
- **3D 재구성**: 점군 생성 및 시각화
- **카메라 캘리브레이션**: 실제 시스템 구축

---

## ⚡ 문제 해결 가이드

### **자주 발생하는 오류**
1. **메모리 부족**: 이미지 크기나 윈도우 크기 줄이기
2. **계산 시간 과다**: 진행률 표시로 학생 안심시키기
3. **결과가 이상함**: 매개변수 범위 확인 